(in-package :first-light.gpu.sdf)

;;;; 2D signed distance field functions
;;;; Credits: https://www.shadertoy.com/view/4dfXDn

(define-function merge ((d1 :float)
                        (d2 :float))
  (min d1 d2))

(define-function merge/smooth ((d1 :float)
                               (d2 :float)
                               (k :float))
  (let ((h (saturate (+ 0.5 (* 0.5 (/ (- d2 d1) k))))))
    (- (mix d2 d1 h) (* k h (- 1 h)))))

(define-function merge/exclude ((d1 :float)
                                (d2 :float))
  (min (max (- d1) d2) (max (- d2) d1)))

(define-function subtract ((d1 :float)
                           (d2 :float))
  (max (- d1) d2))

(define-function intersect ((d1 :float)
                            (d2 :float))
  (max d1 d2))

(define-function rotate/ccw ((p :vec2)
                             (a :float))
  (let ((m (mat2 (cos a) (sin a) (- (sin a)) (cos a))))
    (* p m)))

(define-function rotate/cw ((p :vec2)
                            (a :float))
  (let ((m (mat2 (cos a) (- (sin a)) (sin a) (cos a))))
    (* p m)))

(define-function translate ((p :vec2)
                            (t :vec2))
  (- p t))

(define-function pie ((p :vec2)
                      (angle :float))
  (let* ((angle (/ (radians angle) 2))
         (n (vec2 (cos angle) (sin angle))))
    (+ (* (.x (abs p)) (.x n))
       (* (.y p) (.y n)))))

(define-function dist/circle ((p :vec2)
                              (radius :float))
  (- (length p) radius))

(define-function dist/triangle ((p :vec2)
                                (radius :float))
  (- (max (+ (* (.x (abs p)) 0.866025)
             (* (.y p) 0.5))
          (- (.y p)))
     (* radius 0.5)))

(define-function dist/triangle ((p :vec2)
                                (width :float)
                                (height :float))
  (let ((n (normalize (vec2 height (/ width 2)))))
    (max (+ (* (.x (abs p) (.x n)))
            (- (* (.y p) (.y n))
               (* height (.y n))))
         (- (.y p)))))

(define-function dist/semi-circle ((p :vec2)
                                   (radius :float)
                                   (angle :float)
                                   (width :float))
  (let* ((width (/ width 2))
         (radius (- radius width)))
    (subtract (pie p angle)
              (- (abs (dist/circle p radius))
                 width))))

(define-function dist/box ((p :vec2)
                           (size :vec2)
                           (radius :float))
  (let* ((size (- size (vec2 radius)))
         (d (- (abs p) size)))
    (+ (min (max (.x d) (.y d)) 0)
       (- (length (max d 0)) radius))))

(define-function dist/line ((p :vec2)
                            (start :vec2)
                            (end :vec2)
                            (width :float))
  (let* ((dir (- start end))
         (length (length dir))
         (dir (/ dir length))
         (proj (* (max 0 (min length (dot (- start p) dir)))
                  dir)))
    (- (length (- start p proj))
       (/ width 2))))

(define-function mask/fill ((dist :float))
  (saturate (- dist)))

(define-function mask/inner-border ((dist :float)
                                    (width :float))
  (- (saturate (+ dist width))
     (saturate dist)))

(define-function mask/outer-border ((dist :float)
                                    (width :float))
  (- (saturate dist)
     (saturate (- dist width))))

(define-function shadow ((fn (function (:vec2) :float))
                         (p :vec2)
                         (pos :vec2)
                         (radius :float))
  (let* ((dir (normalize (- pos p)))
         (dl (length (- p pos)))
         (lf (* radius dl))
         (dt 0.01))
    (dotimes (i 64)
      (let ((sd (funcall fn (+ p (* dir dt)))))
        (when (< sd (- radius))
          (return 0.0))
        (setf lf (min lf (/ sd dt)))
        (incf dt (max 1 (abs sd)))
        (when (> dt dl)
          (break))))
    (smoothstep 0 1 (saturate (/ (+ (* lf dl) radius) 2)))))
