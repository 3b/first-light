(in-package :first-light.math)

;;; utilities

(fl.util:eval-always
  (defun %make-accessor-symbol (prefix &rest args)
    (fl.util:format-symbol (symbol-package prefix) "~@:(~{~a~}~)" (cons prefix args))))

;;; vec2

(defstruct (vec2 (:constructor %%vec2 (v2-array))
                 (:conc-name nil)
                 (:predicate nil)
                 (:copier nil))
  (v2-array (make-array 2 :element-type 'single-float)
   :type (simple-array single-float (2))))

(defmacro with-vec2 (((prefix vec) &rest rest) &body body)
  (fl.util:with-unique-names (sym)
    `(let ((,sym ,vec))
       (declare (ignorable ,sym))
       (symbol-macrolet ((,prefix ,sym)
                         (,(%make-accessor-symbol prefix '.x) (aref (v2-array ,sym) 0))
                         (,(%make-accessor-symbol prefix '.y) (aref (v2-array ,sym) 1))
                         (,(%make-accessor-symbol prefix '.r) (aref (v2-array ,sym) 0))
                         (,(%make-accessor-symbol prefix '.g) (aref (v2-array ,sym) 1))
                         (,(%make-accessor-symbol prefix '.s) (aref (v2-array ,sym) 0))
                         (,(%make-accessor-symbol prefix '.t) (aref (v2-array ,sym) 1)))
         ,(if rest
              `(with-vec2 ,rest ,@body)
              `(progn ,@body))))))

(fl.util:define-printer (vec2 stream)
  (with-vec2 ((v vec2))
    (format stream "~f ~f" v.x v.y)))

;;; vec3

(defstruct (vec3 (:constructor %%vec3 (v3-array))
                 (:conc-name nil)
                 (:predicate nil)
                 (:copier nil))
  (v3-array (make-array 3 :element-type 'single-float)
   :type (simple-array single-float (3))))

(defmacro with-vec3 (((prefix vec) &rest rest) &body body)
  (fl.util:with-unique-names (sym)
    `(let ((,sym ,vec))
       (declare (ignorable ,sym))
       (symbol-macrolet ((,prefix ,sym)
                         (,(%make-accessor-symbol prefix '.x) (aref (v3-array ,sym) 0))
                         (,(%make-accessor-symbol prefix '.y) (aref (v3-array ,sym) 1))
                         (,(%make-accessor-symbol prefix '.z) (aref (v3-array ,sym) 2))
                         (,(%make-accessor-symbol prefix '.r) (aref (v3-array ,sym) 0))
                         (,(%make-accessor-symbol prefix '.g) (aref (v3-array ,sym) 1))
                         (,(%make-accessor-symbol prefix '.b) (aref (v3-array ,sym) 2))
                         (,(%make-accessor-symbol prefix '.s) (aref (v3-array ,sym) 0))
                         (,(%make-accessor-symbol prefix '.t) (aref (v3-array ,sym) 1))
                         (,(%make-accessor-symbol prefix '.p) (aref (v3-array ,sym) 2)))
         ,(if rest
              `(with-vec3 ,rest ,@body)
              `(progn ,@body))))))

(fl.util:define-printer (vec3 stream)
  (with-vec3 ((v vec3))
    (format stream "~f ~f ~f" v.x v.y v.z)))

;;; vec4

(defstruct (vec4 (:constructor %%vec4 (v4-array))
                 (:conc-name nil)
                 (:predicate nil)
                 (:copier nil))
  (v4-array (make-array 4 :element-type 'single-float)
   :type (simple-array single-float (4))))

(defmacro with-vec4 (((prefix vec) &rest rest) &body body)
  (fl.util:with-unique-names (sym)
    `(let ((,sym ,vec))
       (declare (ignorable ,sym))
       (symbol-macrolet ((,prefix ,sym)
                         (,(%make-accessor-symbol prefix '.x) (aref (v4-array ,sym) 0))
                         (,(%make-accessor-symbol prefix '.y) (aref (v4-array ,sym) 1))
                         (,(%make-accessor-symbol prefix '.z) (aref (v4-array ,sym) 2))
                         (,(%make-accessor-symbol prefix '.w) (aref (v4-array ,sym) 3))
                         (,(%make-accessor-symbol prefix '.r) (aref (v4-array ,sym) 0))
                         (,(%make-accessor-symbol prefix '.g) (aref (v4-array ,sym) 1))
                         (,(%make-accessor-symbol prefix '.b) (aref (v4-array ,sym) 2))
                         (,(%make-accessor-symbol prefix '.a) (aref (v4-array ,sym) 3))
                         (,(%make-accessor-symbol prefix '.s) (aref (v4-array ,sym) 0))
                         (,(%make-accessor-symbol prefix '.t) (aref (v4-array ,sym) 1))
                         (,(%make-accessor-symbol prefix '.p) (aref (v4-array ,sym) 2))
                         (,(%make-accessor-symbol prefix '.q) (aref (v4-array ,sym) 3)))
         ,(if rest
              `(with-vec4 ,rest ,@body)
              `(progn ,@body))))))

(fl.util:define-printer (vec4 stream)
  (with-vec4 ((v vec4))
    (format stream "~f ~f ~f ~f" v.x v.y v.z v.w)))

;;; mat2

(defstruct (mat2 (:constructor %%mat2 (m2-array))
                 (:conc-name nil)
                 (:predicate nil)
                 (:copier nil))
  (m2-array (make-array 4 :element-type 'single-float)
   :type (simple-array single-float (4))))

(defmacro with-mat2 (((prefix matrix) &rest rest) &body body)
  (fl.util:with-unique-names (sym)
    `(let ((,sym ,matrix))
       (declare (ignorable ,sym))
       (symbol-macrolet ((,prefix ,sym)
                         (,(%make-accessor-symbol prefix ".00") (aref (m2-array ,sym) 0))
                         (,(%make-accessor-symbol prefix ".10") (aref (m2-array ,sym) 1))
                         (,(%make-accessor-symbol prefix ".01") (aref (m2-array ,sym) 2))
                         (,(%make-accessor-symbol prefix ".11") (aref (m2-array ,sym) 3)))
         ,(if rest
              `(with-mat2 ,rest ,@body)
              `(progn ,@body))))))

(fl.util:define-printer (mat2 stream)
  (with-mat2 ((m mat2))
    (format stream "~%  ~f ~f~%  ~f ~f"
            m.00 m.01
            m.10 m.11)))

;;; mat3

(defstruct (mat3 (:constructor %%mat3 (m3-array))
                 (:conc-name nil)
                 (:predicate nil)
                 (:copier nil))
  (m3-array (make-array 9 :element-type 'single-float)
   :type (simple-array single-float (9))))

(defmacro with-mat3 (((prefix matrix) &rest rest) &body body)
  (fl.util:with-unique-names (sym)
    `(let ((,sym ,matrix))
       (declare (ignorable ,sym))
       (symbol-macrolet ((,prefix ,sym)
                         (,(%make-accessor-symbol prefix ".00") (aref (m3-array ,sym) 0))
                         (,(%make-accessor-symbol prefix ".10") (aref (m3-array ,sym) 1))
                         (,(%make-accessor-symbol prefix ".20") (aref (m3-array ,sym) 2))
                         (,(%make-accessor-symbol prefix ".01") (aref (m3-array ,sym) 3))
                         (,(%make-accessor-symbol prefix ".11") (aref (m3-array ,sym) 4))
                         (,(%make-accessor-symbol prefix ".21") (aref (m3-array ,sym) 5))
                         (,(%make-accessor-symbol prefix ".02") (aref (m3-array ,sym) 6))
                         (,(%make-accessor-symbol prefix ".12") (aref (m3-array ,sym) 7))
                         (,(%make-accessor-symbol prefix ".22") (aref (m3-array ,sym) 8)))
         ,(if rest
              `(with-mat3 ,rest ,@body)
              `(progn ,@body))))))

(fl.util:define-printer (mat3 stream)
  (with-mat3 ((m mat3))
    (format stream "~%  ~f ~f ~f~%  ~f ~f ~f~%  ~f ~f ~f"
            m.00 m.01 m.02
            m.10 m.11 m.12
            m.20 m.21 m.22)))

;;; mat4

(defstruct (mat4 (:constructor %%mat4 (m4-array))
                 (:conc-name nil)
                 (:predicate nil)
                 (:copier nil))
  (m4-array (make-array 16 :element-type 'single-float)
   :type (simple-array single-float (16))))

(defmacro with-mat4 (((prefix matrix) &rest rest) &body body)
  (fl.util:with-unique-names (sym)
    `(let ((,sym ,matrix))
       (declare (ignorable ,sym))
       (symbol-macrolet ((,prefix ,sym)
                         (,(%make-accessor-symbol prefix ".00") (aref (m4-array ,sym) 0))
                         (,(%make-accessor-symbol prefix ".10") (aref (m4-array ,sym) 1))
                         (,(%make-accessor-symbol prefix ".20") (aref (m4-array ,sym) 2))
                         (,(%make-accessor-symbol prefix ".30") (aref (m4-array ,sym) 3))
                         (,(%make-accessor-symbol prefix ".01") (aref (m4-array ,sym) 4))
                         (,(%make-accessor-symbol prefix ".11") (aref (m4-array ,sym) 5))
                         (,(%make-accessor-symbol prefix ".21") (aref (m4-array ,sym) 6))
                         (,(%make-accessor-symbol prefix ".31") (aref (m4-array ,sym) 7))
                         (,(%make-accessor-symbol prefix ".02") (aref (m4-array ,sym) 8))
                         (,(%make-accessor-symbol prefix ".12") (aref (m4-array ,sym) 9))
                         (,(%make-accessor-symbol prefix ".22") (aref (m4-array ,sym) 10))
                         (,(%make-accessor-symbol prefix ".32") (aref (m4-array ,sym) 11))
                         (,(%make-accessor-symbol prefix ".03") (aref (m4-array ,sym) 12))
                         (,(%make-accessor-symbol prefix ".13") (aref (m4-array ,sym) 13))
                         (,(%make-accessor-symbol prefix ".23") (aref (m4-array ,sym) 14))
                         (,(%make-accessor-symbol prefix ".33") (aref (m4-array ,sym) 15)))
         ,(if rest
              `(with-mat4 ,rest ,@body)
              `(progn ,@body))))))

(fl.util:define-printer (mat4 stream)
  (with-mat4 ((m mat4))
    (format stream "~%  ~f ~f ~f ~f~%  ~f ~f ~f ~f~%  ~f ~f ~f ~f~%  ~f ~f ~f ~f"
            m.00 m.01 m.02 m.03
            m.10 m.11 m.12 m.13
            m.20 m.21 m.22 m.23
            m.30 m.31 m.32 m.33)))

;;; quat

(defstruct (quat (:constructor %%quat (quat-array))
                 (:conc-name nil)
                 (:predicate nil)
                 (:copier nil))
  (quat-array (make-array 4 :element-type 'single-float)
   :type (simple-array single-float (4))))

(defmacro with-quat (((prefix quat) &rest rest) &body body)
  (fl.util:with-unique-names (sym)
    `(let ((,sym ,quat))
       (declare (ignorable ,sym))
       (symbol-macrolet ((,prefix ,sym)
                         (,(%make-accessor-symbol prefix '.w) (aref (quat-array ,sym) 0))
                         (,(%make-accessor-symbol prefix '.x) (aref (quat-array ,sym) 1))
                         (,(%make-accessor-symbol prefix '.y) (aref (quat-array ,sym) 2))
                         (,(%make-accessor-symbol prefix '.z) (aref (quat-array ,sym) 3)))
         ,(if rest
              `(with-quat ,rest ,@body)
              `(progn ,@body))))))

(fl.util:define-printer (quat stream)
  (with-quat ((q quat))
    (format stream "~f ~f ~f ~f" q.w q.x q.y q.z)))

;;; constructors

(fl.util:fn-> %vec2 (&rest single-float) vec2)
(defun %vec2 (&rest args)
  (%%vec2 (make-array 2 :element-type 'single-float :initial-contents args)))

(fl.util:fn-> %vec3 (&rest single-float) vec3)
(defun %vec3 (&rest args)
  (%%vec3 (make-array 3 :element-type 'single-float :initial-contents args)))

(fl.util:fn-> %vec4 (&rest single-float) vec4)
(defun %vec4 (&rest args)
  (%%vec4 (make-array 4 :element-type 'single-float :initial-contents args)))

(fl.util:fn-> %mat2 (&rest single-float) mat2)
(defun %mat2 (&rest args)
  (%%mat2 (make-array 4 :element-type 'single-float :initial-contents args)))

(fl.util:fn-> %mat3 (&rest single-float) mat3)
(defun %mat3 (&rest args)
  (%%mat3 (make-array 9 :element-type 'single-float :initial-contents args)))

(fl.util:fn-> %mat4 (&rest single-float) mat4)
(defun %mat4 (&rest args)
  (%%mat4 (make-array 16 :element-type 'single-float :initial-contents args)))

(fl.util:fn-> %quat (&rest single-float) quat)
(defun %quat (&rest args)
  (%%quat (make-array 4 :element-type 'single-float :initial-contents args)))

;;; store functions

(defstore vec2 (&rest args))
(defstore vec3 (&rest args))
(defstore vec4 (&rest args))
(defstore mat2 (&rest args))
(defstore mat3 (&rest args))
(defstore mat4 (&rest args))
(defstore quat (&rest args))
(defstore copy (in &rest args))
(defstore copy-into (out &rest args))
(defstore x (vec))
(defstore (setf x) (value vec))
(defstore y (vec))
(defstore (setf y) (value vec))
(defstore z (vec))
(defstore (setf z) (value vec))
(defstore w (vec))
(defstore (setf w) (value vec))
(defstore rand (in min max &optional out))
(defstore zero (out))
(defstore zero-p (in))
(defstore unit-p (in))
(defstore id (out))
(defstore id-p (in))
(defstore clamp (in min max &optional out))
(defstore stabilize (in tolerance &optional out))
(defstore + (in1 in2 &optional out))
(defstore - (in1 in2 &optional out))
(defstore * (in1 in2 &optional out))
(defstore / (in1 in2 &optional out))
(defstore sign (in &optional out))
(defstore fract (in &optional out))
(defstore dot (in1 in2))
(defstore cross (in1 in2 &optional out))
(defstore length-squared (in))
(defstore length (in))
(defstore distance-squared (in1 in2))
(defstore distance (in1 in2))
(defstore normalize (in &optional out))
(defstore negate (in &optional out))
(defstore lerp (in1 in2 factor &optional out))
(defstore angle (in1 in2))
(defstore radians (in &optional out))
(defstore degrees (in &optional out))
(defstore = (in1 in2))
(defstore ~ (in1 in2))
(defstore < (in1 in2))
(defstore <= (in1 in2))
(defstore > (in1 in2))
(defstore >= (in1 in2))
(defstore expt (in power &optional out))
(defstore sqrt (in &optional out))
(defstore floor (in &optional out))
(defstore ceiling (in &optional out))
(defstore mod (in divisor &optional out))
(defstore round (in &optional out))
(defstore abs (in &optional out))
(defstore min (in1 in2 &optional out))
(defstore max (in1 in2 &optional out))
(defstore sin (in &optional out))
(defstore cos (in &optional out))
(defstore tan (in &optional out))
(defstore asin (in &optional out))
(defstore acos (in &optional out))
(defstore atan (in &optional out))
(defstore direction= (in1 in2))
(defstore parallel-p (in1 in2))
(defstore get-array (mat))
(defstore get-column (mat index &optional out))
(defstore set-column (mat index vec &optional out))
(defstore get-translation (mat &optional out))
(defstore set-translation (mat vec &optional out))
(defstore translate (mat vec &optional out))
(defstore rotate (kind in angle &optional out))
(defstore get-scale (mat &optional out))
(defstore set-scale (mat vec &optional out))
(defstore scale (mat vec &optional out))
(defstore transpose (mat &optional out))
(defstore orthogonal-p (mat))
(defstore orthonormalize (mat &optional out))
(defstore trace (mat))
(defstore diagonal-p (mat))
(defstore main-diagonal (mat &optional out))
(defstore anti-diagonal (mat &optional out))
(defstore determinant (mat))
(defstore invert-orthonormal (mat &optional out))
(defstore invert (mat &optional out))
(defstore set-view (eye target up &optional out))
(defstore set-projection/orthographic (left right bottom top near far &optional out))
(defstore set-projection/perspective (fov aspect near far &optional out))
(defstore conjugate (quat &optional out))
(defstore inverse (quat &optional out))
(defstore slerp (in1 in2 factor &optional out))
